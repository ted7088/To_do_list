SRP : 단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 한다.
하나의 책임이라는것은 모호하다.
그러나, 중요한건 변경 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것

OCP : 개방 폐쇄 원칙 (Open/Closed principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
다형성을 활용해서 !!
인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
ex) MemberRepository m = new MemoryMemberRepository(); //기존코드
    MemberRepository m = new JdbcMemberRepository(); // 변경 코드
이렇게 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
객체를 생성하고, 연관관계를 맺어주는 별도의 조립이 필요하다.

LSP : 리스코프 치환 원칙 (Liskov subtitution principle)
자동차 인터페이스가 있다고 가정했을때 구현체가 악셀이라는것을 구현했음
근데 사실 악셀을 개발하는건 앞으로 10만 개발하는게 아닐수도 있지 않음?
그러나 우리는 규약으로 앞으로 가야한다는 것을 원칙적으로 정해놓고 개발해야함
이걸 위반해서는 안된다 이런의미
정리하면, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야함

ISP : 인터페이스 분리 원칙 (Interface segregation principle)
특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
자동차 인터페이스 -> 운전 인터페이스 ,정비 인터페이스로 분리
사용자 클라이언트 -> 운전자 클라이언트 , 정비사 클라이언트로 분리
분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
인터페이스가 명확해지고 대체 가능성이 높아진다.

DIP : 의존관계 역전 원칙
Dependency inversion principle
클라이언트 코드가 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
역할에 의존하게 되어야 한다는 것과 똑같아야함
마치 운전자가 아반떼에만 집중하는게 아니라, 자동차에 집중을 해야하는것과 마찬가지 원리.


